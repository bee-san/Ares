//! Decodes a Base62 string
//! Performs error handling and returns a string
//! Call base62_decoder.crack to use. It returns option<String> and check with
//! `result.is_some()` to see if it returned okay.

use crate::checkers::CheckerTypes;
use crate::decoders::interface::check_string_success;

use super::crack_results::CrackResult;
use super::interface::Crack;
use super::interface::Decoder;

use log::{debug, info, trace};

/// The Base62 decoder, call:
/// `let base62_decoder = Decoder::<Base62Decoder>::new()` to create a new instance
/// And then call:
/// `result = base62_decoder.crack(input)` to decode a base62 string
/// The struct generated by new() comes from interface.rs
/// ```
/// use ciphey::decoders::base62_decoder::{Base62Decoder};
/// use ciphey::decoders::interface::{Crack, Decoder};
/// use ciphey::checkers::{athena::Athena, CheckerTypes, checker_type::{Check, Checker}};
///
/// let decode_base62 = Decoder::<Base62Decoder>::new();
/// let athena_checker = Checker::<Athena>::new();
/// let checker = CheckerTypes::CheckAthena(athena_checker);
///
/// let result = decode_base62.crack("T8dgcjRGkZ3aysdN", &checker).unencrypted_text;
/// assert!(result.is_some());
/// assert_eq!(result.unwrap()[0], "Hello World!");
/// ```
pub struct Base62Decoder;

impl Crack for Decoder<Base62Decoder> {
    fn new() -> Decoder<Base62Decoder> {
        Decoder {
            name: "Base62",
            description: "Base62 is a binary-to-text encoding scheme that represents binary data using 62 alphanumeric characters (0-9, A-Z, a-z). It is commonly used for URL shorteners, unique identifiers, and cases where special characters should be avoided.",
            link: "https://en.wikipedia.org/wiki/Base62",
            tags: vec!["base62", "decoder", "base"],
            popularity: 0.6,
            phantom: std::marker::PhantomData,
        }
    }

    /// This function does the actual decoding
    /// It returns an Option<string> if it was successful
    /// Else the Option returns nothing and the error is logged in Trace
    fn crack(&self, text: &str, checker: &CheckerTypes) -> CrackResult {
        trace!("Trying Base62 with text {:?}", text);
        let decoded_text = decode_base62_no_error_handling(text);
        let mut results = CrackResult::new(self, text.to_string());

        if decoded_text.is_none() {
            debug!("Failed to decode base62 because Base62Decoder::decode_base62_no_error_handling returned None");
            return results;
        }

        let decoded_text = decoded_text.unwrap();
        if !check_string_success(&decoded_text, text) {
            info!(
                "Failed to decode base62 because check_string_success returned false on string {}",
                decoded_text
            );
            return results;
        }

        let checker_result = checker.check(&decoded_text);
        results.unencrypted_text = Some(vec![decoded_text]);

        results.update_checker(&checker_result);

        results
    }

    /// Gets all tags for this decoder
    fn get_tags(&self) -> &Vec<&str> {
        &self.tags
    }

    /// Gets the name for the current decoder
    fn get_name(&self) -> &str {
        self.name
    }

    /// Gets the description for the current decoder
    fn get_description(&self) -> &str {
        self.description
    }

    /// Gets the link for the current decoder
    fn get_link(&self) -> &str {
        self.link
    }
}

/// Base62 alphabet: 0-9, A-Z, a-z
const BASE62_ALPHABET: &[u8] = b"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

/// helper function to decode base62 encoded string to bytes
fn decode_base62_no_error_handling(text: &str) -> Option<String> {
    if text.is_empty() {
        return None;
    }

    // Build a lookup table for character to value mapping
    let mut char_to_value = [255u8; 128];
    for (i, &c) in BASE62_ALPHABET.iter().enumerate() {
        char_to_value[c as usize] = i as u8;
    }

    // Decode base62 to a big integer represented as bytes
    // Start with 0
    let mut result: Vec<u8> = vec![0];

    for c in text.bytes() {
        // Check if character is valid ASCII and in our alphabet
        if c >= 128 || char_to_value[c as usize] == 255 {
            return None;
        }
        let value = char_to_value[c as usize];

        // Multiply result by 62 and add the new digit
        let mut carry = value as u16;
        for byte in result.iter_mut().rev() {
            let product = (*byte as u16) * 62 + carry;
            *byte = (product & 0xFF) as u8;
            carry = product >> 8;
        }

        // Handle any remaining carry
        while carry > 0 {
            result.insert(0, (carry & 0xFF) as u8);
            carry >>= 8;
        }
    }

    // Remove leading zeros (but keep at least one byte)
    while result.len() > 1 && result[0] == 0 {
        result.remove(0);
    }

    String::from_utf8(result).ok()
}

#[cfg(test)]
mod tests {
    use super::Base62Decoder;
    use crate::{
        checkers::{
            athena::Athena,
            checker_type::{Check, Checker},
            CheckerTypes,
        },
        decoders::interface::{Crack, Decoder},
    };

    // helper for tests
    fn get_athena_checker() -> CheckerTypes {
        let athena_checker = Checker::<Athena>::new();
        CheckerTypes::CheckAthena(athena_checker)
    }

    #[test]
    fn successful_decoding() {
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder.crack("T8dgcjRGkZ3aysdN", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello World!");
    }

    #[test]
    fn base62_decode_empty_string() {
        // Base62 returns an empty string, this is a valid base62 string
        // but returns False on check_string_success
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder
            .crack("", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn base62_decode_handles_panics() {
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder
            .crack(
                "hello my name is panicky mc panic face!",
                &get_athena_checker(),
            )
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn base62_handle_panic_if_empty_string() {
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder
            .crack("", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn base62_handle_panic_if_emoji() {
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder
            .crack("ðŸ˜‚", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn base62_handles_invalid_characters() {
        // Base62 only uses alphanumeric characters, so special chars should fail
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder
            .crack("abc+def/ghi=", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }
}
