///! Decode a base62 string
///! Performs error handling and returns a string
///! Call base62_decoder.crack to use. It returns option<String> and check with
///! `result.is_some()` to see if it returned okay.
///
use crate::checkers::CheckerTypes;
use crate::decoders::interface::check_string_success;

use super::crack_results::CrackResult;
use super::interface::Crack;
use super::interface::Decoder;

use log::{debug, info, trace};

/// The base62 decoder, call:
/// `let base62_decoder = Decoder::<Base62Decoder>::new()` to create a new instance
/// And then call:
/// `result = base62_decoder.crack(input)` to decode a base62 string
/// The struct generated by new() comes from interface.rs
/// ```
/// use ares::decoders::base62_decoder::{Base62Decoder};
/// use ares::decoders::interface::{Crack, Decoder};
/// use ares::checkers::{athena::Athena, CheckerTypes, checker_type::{Check, Checker}};
///
/// let decode_base62 = Decoder::<Base62Decoder>::new();
/// let athena_checker = Checker::<Athena>::new();
/// let checker = CheckerTypes::CheckAthena(athena_checker);
///
/// let result = decode_base62.crack("𒅓鹨𖡮𒀠啦ꍢ顡啫𓍱𓁡𠁴唬𓍪鱤啥𖥭𔐠𔕯ᔮ", &checker).unencrypted_text;
/// assert!(result.is_some());
/// assert_eq!(result.unwrap(), "Sphinx of black quartz, judge my vow.");
/// ```
pub struct Base62Decoder;

impl Crack for Decoder<Base62Decoder> {
    fn new() -> Decoder<Base62Decoder> {
        Decoder {
            name: "base62",
            description: "The base62 encoding scheme uses 62 characters. The characters consist of the capital letters A-Z, the lower case letters a-z and the numbers 0–9.",
            link: "https://en.wikipedia.org/wiki/Base62",
            tags: vec!["base62", "decoder", "base"],
            expected_runtime: 0.01,
            expected_success: 1.0,
            failure_runtime: 0.01,
            normalised_entropy: vec![1.0, 10.0],
            popularity: 0.5,
            phantom: std::marker::PhantomData,
        }
    }

    /// This function does the actual decoding
    /// It returns an Option<string> if it was successful
    /// Else the Option returns nothing and the error is logged in Trace
    fn crack(&self, text: &str, checker: &CheckerTypes) -> CrackResult {
        trace!("Trying base62 with text {:?}", text);
        let decoded_text: Option<String> = decode_base62_no_error_handling(text);

        trace!("Decoded text for base62: {:?}", decoded_text);
        let mut results = CrackResult::new(self, text.to_string());

        if decoded_text.is_none() {
            debug!("Failed to decode base62 because Base62Decoder::decode_base62_no_error_handling returned None");
            return results;
        }

        let decoded_text = decoded_text.unwrap();
        if !check_string_success(&decoded_text, text) {
            info!(
                "Failed to decode base62 because check_string_success returned false on string {}",
                decoded_text
            );
            return results;
        }

        let checker_result = checker.check(&decoded_text);
        results.unencrypted_text = Some(decoded_text);

        results.update_checker(&checker_result);

        results
    }
}

/// helper function
fn decode_base62_no_error_handling(text: &str) -> Option<String> {
    // Runs the code to decode base62
    // Doesn't perform error handling, call from_base62
    if let Ok(decoded_text) = base62::decode(text) {
        return Some(decoded_text.to_string());
    }
    debug!("{:?}", base62::decode("2PYz5rmnETyCvSjWRbX6UvHjskCCHERL7Zdk9D8WVFtHuPb5vfwwjiXFVJXWnW5JlZ6xZicQsco570Mu7XB4D0JNjFfNCxPls7wCsgVTn64uhSTyg1u45ec947BtRJ7YSVsvLp1Rfb0Y3PrYDnqOHdVVA9R1KMkD6t1elsRNTFF8rXQqjGiC4OU5ugooDFx9sv9m7aYMhufbHMSgKQLaYCHAeVniBtezSm08nnoMsMIHQVZfl5w3VqiBP9DGFoG3OjjgkAw9ofaqvRPk9hUFuK690Q5UGdLmjHewvHRXsuv9Gap7sg7nuvIY3J3a9WuGTb7JPT7318ZMPFdmyqktYL8VzcCBmBQMplVflFGBXV8qn3hMtp8AnFnt6WiIgv4pDLoT9hwZZ7Mai3oKui8ElWbcgzi21"));
    None
}

#[cfg(test)]
mod tests {
    use super::Base62Decoder;
    use crate::{
        checkers::{
            athena::Athena,
            checker_type::{Check, Checker},
            CheckerTypes,
        },
        decoders::interface::{Crack, Decoder},
    };

    // helper for tests
    fn get_athena_checker() -> CheckerTypes {
        let athena_checker = Checker::<Athena>::new();
        CheckerTypes::CheckAthena(athena_checker)
    }

    #[test]
    fn base62_decodes_successfully() {
        // This tests if Base62 can decode Base62 successfully
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder.crack("𒅓鹨𖡮𒀠啦ꍢ顡啫𓍱𓁡𠁴唬𓍪鱤啥𖥭𔐠𔕯ᔮ", &get_athena_checker());
        assert_eq!(
            result.unencrypted_text.unwrap(),
            "Sphinx of black quartz, judge my vow."
        );
    }

    #[test]
    fn base62_handles_panics() {
        // This tests if Base62 can handle panics
        // It should return None
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder
            .crack(
                "hello my name is panicky mc panic face!",
                &get_athena_checker(),
            )
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn base62_handles_panic_if_empty_string() {
        // This tests if Base62 can handle an empty string
        // It should return None
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder
            .crack("", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn base62_handles_panic_if_emoji() {
        // This tests if Base62 can handle an emoji
        // It should return None
        let base62_decoder = Decoder::<Base62Decoder>::new();
        let result = base62_decoder
            .crack("😂", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }
}
