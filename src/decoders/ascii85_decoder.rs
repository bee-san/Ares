//! Decode an Ascii85 (Base85) string
//! Performs error handling and returns a string
//! Call ascii85_decoder.crack to use. It returns option<String> and check with
//! `result.is_some()` to see if it returned okay.

use crate::checkers::CheckerTypes;
use crate::decoders::interface::check_string_success;
use crate::decoders::crack_results::CrackResult;
use crate::decoders::interface::Crack;
use crate::decoders::interface::Decoder;

use log::{debug, info, trace};

/// The Ascii85 decoder, call:
/// `let ascii85_decoder = Decoder::<Ascii85Decoder>::new()` to create a new instance
/// And then call:
/// `result = ascii85_decoder.crack(input)` to decode a ascii85 string
/// The struct generated by new() comes from interface.rs
/// ```
/// use ciphey::decoders::ascii85_decoder::{Ascii85Decoder};
/// use ciphey::decoders::interface::{Crack, Decoder};
/// use ciphey::checkers::{athena::Athena, CheckerTypes, checker_type::{Check, Checker}};
///
/// let decode_ascii85 = Decoder::<Ascii85Decoder>::new();
/// let athena_checker = Checker::<Athena>::new();
/// let checker = CheckerTypes::CheckAthena(athena_checker);
///
/// let result = decode_ascii85.crack("87cURD]i,\"Ebo7", &checker).unencrypted_text;
/// assert!(result.is_some());
/// assert_eq!(result.unwrap()[0], "Hello World");
/// ```
pub struct Ascii85Decoder;

impl Crack for Decoder<Ascii85Decoder> {
    fn new() -> Decoder<Ascii85Decoder> {
        Decoder {
            name: "Ascii85",
            description: "Ascii85 (also called Base85) is a binary-to-text encoding scheme. It represents 4 bytes of binary data with 5 ASCII characters. It is often used in Adobe's PostScript and PDF file formats.",
            link: "https://en.wikipedia.org/wiki/Ascii85",
            tags: vec!["ascii85", "base85", "decoder", "adobe"],
            popularity: 0.6,
            phantom: std::marker::PhantomData,
        }
    }

    /// This function does the actual decoding
    /// It returns an Option<string> if it was successful
    /// Else the Option returns nothing and the error is logged in Trace
    fn crack(&self, text: &str, checker: &CheckerTypes) -> CrackResult {
        trace!("Trying Ascii85 with text {:?}", text);
        let mut results = CrackResult::new(self, text.to_string());
        let decoded_text = decode_ascii85_no_error_handling(text);

        if decoded_text.is_none() {
            debug!("Failed to decode ascii85 because decode_ascii85_no_error_handling returned None");
            return results;
        }

        let decoded_text = decoded_text.unwrap();
        if !check_string_success(&decoded_text, text) {
            info!(
                "Failed to decode ascii85 because check_string_success returned false on string {}",
                decoded_text
            );
            return results;
        }

        let checker_result = checker.check(&decoded_text);
        results.unencrypted_text = Some(vec![decoded_text]);
        results.update_checker(&checker_result);

        results
    }

    /// Gets all tags for this decoder
    fn get_tags(&self) -> &Vec<&str> {
        &self.tags
    }
    /// Gets the name for the current decoder
    fn get_name(&self) -> &str {
        self.name
    }
    /// Gets the popularity for the current decoder
    fn get_popularity(&self) -> f32 {
        self.popularity
    }
    /// Gets the description for the current decoder
    fn get_description(&self) -> &str {
        self.description
    }
    /// Gets the link for the current decoder
    fn get_link(&self) -> &str {
        self.link
    }
}

/// helper function for ascii85 decoding
fn decode_ascii85_no_error_handling(input: &str) -> Option<String> {
    if input.is_empty() {
        return None;
    }

    // Handle standard delimiters <~ and ~>
    let mut text = input.trim();
    if text.starts_with("<~") {
        text = &text[2..];
    }
    if text.ends_with("~>") {
        text = &text[..text.len()-2];
    }

    // Remove whitespace
    let clean_input: String = text.chars().filter(|c| !c.is_whitespace()).collect();

    // Process 'z' (zero block) and 'y' (space block) compression
    let mut expanded = Vec::new();
    for c in clean_input.chars() {
        if c == 'z' {
            expanded.push('!');
            expanded.push('!');
            expanded.push('!');
            expanded.push('!');
            expanded.push('!');
        } else if c == 'y' {
             // unofficial but common extension for spaces
             // Ascii85 for spaces is "+<VdL"
             expanded.extend("+<VdL".chars());
        } else {
            expanded.push(c);
        }
    }

    let mut output = Vec::new();
    let mut i = 0;
    while i < expanded.len() {
        // Chunk of 5
        let mut chunk_val: u32 = 0;
        let mut count = 0;

        for j in 0..5 {
            if i + j < expanded.len() {
                let char_code = expanded[i + j] as u8;
                if char_code < 33 || char_code > 117 {
                    return None;
                }
                chunk_val = chunk_val.wrapping_mul(85).wrapping_add((char_code - 33) as u32);
                count += 1;
            } else {
                // Padding
                chunk_val = chunk_val.wrapping_mul(85).wrapping_add(84); // 'u' - 33 = 117 - 33 = 84
            }
        }

        let mut bytes = Vec::new();
        for _ in 0..4 {
             bytes.push((chunk_val >> 24) as u8);
             chunk_val <<= 8;
        }

        if count == 5 {
            output.extend_from_slice(&bytes);
        } else {
             // Padding handling:
             // We output count-1 bytes.
             if count > 1 {
                for k in 0..(count - 1) {
                    output.push(bytes[k]);
                }
             } else {
                 // 1 char chunk is invalid
                 return None;
             }
        }

        i += 5;
    }

    String::from_utf8(output).ok()
}

#[cfg(test)]
mod tests {
    use super::Ascii85Decoder;
    use crate::{
        checkers::{
            athena::Athena,
            checker_type::{Check, Checker},
            CheckerTypes,
        },
        decoders::interface::{Crack, Decoder},
    };

    fn get_athena_checker() -> CheckerTypes {
        let athena_checker = Checker::<Athena>::new();
        CheckerTypes::CheckAthena(athena_checker)
    }

    #[test]
    fn ascii85_hello_world() {
        let decoder = Decoder::<Ascii85Decoder>::new();
        // "Hello World" -> 87cURD]i,"Ebo7
        let result = decoder.crack("87cURD]i,\"Ebo7", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello World");
    }

    #[test]
    fn ascii85_with_delimiters() {
        let decoder = Decoder::<Ascii85Decoder>::new();
        let result = decoder.crack("<~87cURD]i,\"Ebo7~>", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello World");
    }

    #[test]
    fn ascii85_z_compression() {
        let decoder = Decoder::<Ascii85Decoder>::new();
        let result = decoder.crack("z", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "\0\0\0\0");
    }

    #[test]
    fn ascii85_padding_cases() {
        let decoder = Decoder::<Ascii85Decoder>::new();
        let result = decoder.crack("5l", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "A");
    }

    #[test]
    fn ascii85_empty() {
        let decoder = Decoder::<Ascii85Decoder>::new();
        let result = decoder.crack("", &get_athena_checker());
        assert!(result.unencrypted_text.is_none());
    }

    #[test]
    fn ascii85_invalid_char() {
        let decoder = Decoder::<Ascii85Decoder>::new();
        let result = decoder.crack("NotAscii85~", &get_athena_checker());
        assert!(result.unencrypted_text.is_none());
    }

    #[test]
    fn ascii85_whitespace() {
        let decoder = Decoder::<Ascii85Decoder>::new();
        let result = decoder.crack("8 7c URD] i,\" Ebo7", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello World");
    }

    #[test]
    fn ascii85_emoji_fail() {
        let decoder = Decoder::<Ascii85Decoder>::new();
        let result = decoder.crack("ðŸ˜‚", &get_athena_checker());
        assert!(result.unencrypted_text.is_none());
    }

    #[test]
    fn ascii85_man_page_example() {
        let encoded = "9jqo^BlbD-BleB1DJ+*+F(f,q/0JhKF<GL>Cj@.4Gp$d7F!,L7@<6@)/0JDEF<G%<+EV:2F!,O<DJ+*.@<*K0@<6L(Df-\\0Ec5e;DffZ(EZee.Bl.9pF\"AGXBPCsi+DGm>@3BB/F*&OCAfu2/AKYi(DIb:@FD,*)+C]U=@3BN#EcYf8ATD3s@q?d$AftVqCh[NqF<G:8+EV:.+Cf>-FD5W8ARlolDIal(DId<j@<?3r@:F%a+D58'ATD4$Bl@l3De:,-DJs`8ARoFb/0JMK@qB4^F!,R<AKZ@-DfTqBG%G>uD.RTpAKYo'+CT/5+Cei#DII?(E,9)oF*2M7/c";
        let decoder = Decoder::<Ascii85Decoder>::new();
        let result = decoder.crack(encoded, &get_athena_checker());
        assert!(result.unencrypted_text.is_some());
        assert!(result.unencrypted_text.unwrap()[0].starts_with("Man is distinguished"));
    }
}
