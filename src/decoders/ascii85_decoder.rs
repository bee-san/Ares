//! Decodes an ASCII85 (Base85/btoa) string
//! Performs error handling and returns a string
//! Call ascii85_decoder.crack to use. It returns Option<String> and check with
//! `result.is_some()` to see if it returned okay.

use crate::checkers::CheckerTypes;
use crate::decoders::interface::check_string_success;

use super::crack_results::CrackResult;
use super::interface::Crack;
use super::interface::Decoder;

use log::{debug, info, trace};
use std::panic;

/// The ASCII85 decoder, call:
/// `let ascii85_decoder = Decoder::<Ascii85Decoder>::new()` to create a new instance
/// And then call:
/// `result = ascii85_decoder.crack(input)` to decode an ASCII85 string
/// The struct generated by new() comes from interface.rs
/// ```
/// use ciphey::decoders::ascii85_decoder::{Ascii85Decoder};
/// use ciphey::decoders::interface::{Crack, Decoder};
/// use ciphey::checkers::{athena::Athena, CheckerTypes, checker_type::{Check, Checker}};
///
/// let decode_ascii85 = Decoder::<Ascii85Decoder>::new();
/// let athena_checker = Checker::<Athena>::new();
/// let checker = CheckerTypes::CheckAthena(athena_checker);
///
/// let result = decode_ascii85.crack("87cURD]j7BEbo80", &checker).unencrypted_text;
/// assert!(result.is_some());
/// assert_eq!(result.unwrap()[0], "Hello world!");
/// ```
pub struct Ascii85Decoder;

impl Crack for Decoder<Ascii85Decoder> {
    fn new() -> Decoder<Ascii85Decoder> {
        Decoder {
            name: "Ascii85",
            description: "ASCII85 (also called Base85 or btoa) is a form of binary-to-text encoding that uses five ASCII characters to represent four bytes of binary data. The btoa variant commonly uses <~ and ~> delimiters.",
            link: "https://en.wikipedia.org/wiki/Ascii85",
            tags: vec!["ascii85", "base85", "btoa", "decoder", "base"],
            popularity: 0.6,
            phantom: std::marker::PhantomData,
        }
    }

    /// This function does the actual decoding
    /// It returns an Option<string> if it was successful
    /// Else the Option returns nothing and the error is logged in Trace
    fn crack(&self, text: &str, checker: &CheckerTypes) -> CrackResult {
        trace!("Trying ASCII85 with text {:?}", text);
        let decoded_text = decode_ascii85_no_error_handling(text);
        let mut results = CrackResult::new(self, text.to_string());

        if decoded_text.is_none() {
            debug!(
                "Failed to decode ASCII85 because decode_ascii85_no_error_handling returned None"
            );
            return results;
        }

        let decoded_text = decoded_text.unwrap();
        if !check_string_success(&decoded_text, text) {
            info!(
                "Failed to decode ASCII85 because check_string_success returned false on string {}",
                decoded_text
            );
            return results;
        }

        let checker_result = checker.check(&decoded_text);
        results.unencrypted_text = Some(vec![decoded_text]);

        results.update_checker(&checker_result);

        results
    }

    /// Gets all tags for this decoder
    fn get_tags(&self) -> &Vec<&str> {
        &self.tags
    }

    /// Gets the name for the current decoder
    fn get_name(&self) -> &str {
        self.name
    }

    /// Gets the description for the current decoder
    fn get_description(&self) -> &str {
        self.description
    }

    /// Gets the link for the current decoder
    fn get_link(&self) -> &str {
        self.link
    }
}

/// Helper function to decode ASCII85
/// Handles both delimited (<~...~>) and non-delimited formats
/// Uses panic::catch_unwind to handle arithmetic overflow panics from the ascii85 crate
fn decode_ascii85_no_error_handling(text: &str) -> Option<String> {
    // Try to decode the text
    // The ascii85 crate handles both delimited and non-delimited formats
    let text_to_decode = text.trim();

    // Check if text has btoa-style delimiters and strip them
    let stripped_text = if text_to_decode.starts_with("<~") && text_to_decode.ends_with("~>") {
        &text_to_decode[2..text_to_decode.len() - 2]
    } else {
        text_to_decode
    };

    // Need to own the string for catch_unwind (requires 'static or owned data)
    let stripped_owned = stripped_text.to_string();

    // Temporarily suppress panic output - the default panic hook prints to stderr,
    // which runs BEFORE catch_unwind catches the panic
    let prev_hook = panic::take_hook();
    panic::set_hook(Box::new(|_| {})); // Silent no-op hook

    // Catch any panics from the ascii85 library (e.g., arithmetic overflow on invalid input)
    let result = panic::catch_unwind(|| ascii85::decode(&stripped_owned));

    // Restore the original panic hook
    panic::set_hook(prev_hook);

    match result {
        Ok(Ok(decoded_bytes)) => String::from_utf8(decoded_bytes).ok(),
        Ok(Err(_)) => None, // Library returned a decode error
        Err(_) => None,     // Library panicked (e.g., arithmetic overflow)
    }
}

#[cfg(test)]
mod tests {
    use super::Ascii85Decoder;
    use crate::{
        checkers::{
            athena::Athena,
            checker_type::{Check, Checker},
            CheckerTypes,
        },
        decoders::interface::{Crack, Decoder},
    };

    // helper for tests
    fn get_athena_checker() -> CheckerTypes {
        let athena_checker = Checker::<Athena>::new();
        CheckerTypes::CheckAthena(athena_checker)
    }

    #[test]
    fn ascii85_successful_decoding() {
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let result = ascii85_decoder.crack("87cURD]j7BEbo80", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello world!");
    }

    #[test]
    fn ascii85_successful_decoding_with_delimiters() {
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let result = ascii85_decoder.crack("<~87cURD]j7BEbo80~>", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello world!");
    }

    #[test]
    fn ascii85_decodes_hello_world() {
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let result = ascii85_decoder.crack("87cURD]j7BEbo7", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello world");
    }

    #[test]
    fn ascii85_decode_empty_string() {
        // ASCII85 returns an empty string, this is a valid ascii85 string
        // but returns False on check_string_success
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let result = ascii85_decoder
            .crack("", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn ascii85_decode_handles_panics() {
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let result = ascii85_decoder
            .crack(
                "hello my name is panicky mc panic face!",
                &get_athena_checker(),
            )
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn ascii85_handle_panic_if_empty_string() {
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let result = ascii85_decoder
            .crack("", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn ascii85_handle_panic_if_emoji() {
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let result = ascii85_decoder
            .crack("ðŸ˜‚", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn ascii85_handles_overflow_panic_on_ip_address() {
        // IP addresses and other invalid input cause arithmetic overflow in ascii85 crate
        // This test ensures we catch the panic and return None gracefully
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let result = ascii85_decoder
            .crack("192.168.1.1", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn ascii85_handles_overflow_panic_on_random_text() {
        // Various random text inputs that may trigger arithmetic overflow
        let ascii85_decoder = Decoder::<Ascii85Decoder>::new();
        let test_inputs = vec![
            "123.456.789.0",
            "test.example.com",
            "user@example.com",
            "random garbage text that might overflow",
        ];
        for input in test_inputs {
            let result = ascii85_decoder
                .crack(input, &get_athena_checker())
                .unencrypted_text;
            // Should not panic, may return Some or None depending on decode result
            // The important thing is that it doesn't crash
            let _ = result;
        }
    }
}
