///! Decode a ascii85 string
///! Performs error handling and returns a string
///! Call ascii85_decoder.crack to use. It returns option<String> and check with
///! `result.is_some()` to see if it returned okay.
///
use crate::checkers::CheckerTypes;
use crate::decoders::interface::check_string_success;
use ascii85;

use super::crack_results::CrackResult;
use super::interface::Crack;
use super::interface::Decoder;

use log::{debug, info, trace};

/// The ASCII85 decoder, call:
/// `let ascii85_decoder = Decoder::<ASCII85Decoder>::new()` to create a new instance
/// And then call:
/// `result = ascii85_decoder.crack(input)` to decode a ascii85 string
/// The struct generated by new() comes from interface.rs
/// ```
/// use ares::decoders::ascii85_decoder::{ASCII85Decoder};
/// use ares::decoders::interface::{Crack, Decoder};
/// use ares::checkers::{athena::Athena, CheckerTypes, checker_type::{Check, Checker}};
///
/// let decode_ascii85 = Decoder::<ASCII85Decoder>::new();
/// let athena_checker = Checker::<Athena>::new();
/// let checker = CheckerTypes::CheckAthena(athena_checker);
///
/// let result = decode_ascii85.crack("BOu!rD]j7BEbo7", &checker).unencrypted_text;
/// assert!(result.is_some());
/// assert_eq!(result.unwrap()[0], "hello world");
/// ```
pub struct ASCII85Decoder;

impl Crack for Decoder<ASCII85Decoder> {
    fn new() -> Decoder<ASCII85Decoder> {
        Decoder {
            name: "ASCII85",
            description: "Ascii85, also called Base85, is a form of binary-to-text encoding that uses five ASCII characters to represent four bytes of binary data. Adobe adopted the basic btoa encoding, but with slight changes, and gave it the name Ascii85. The characters used are the ASCII characters 33 (!) through 117 (u) inclusive (to represent the base-85 digits 0 through 84), together with the letter z (as a special case to represent a 32-bit 0 value), and white space is ignored.",
            link: "https://en.wikipedia.org/wiki/Ascii85#Adobe_version",
            tags: vec!["decoder", "ascii85", "base85"],
            popularity: 0.6,
            phantom: std::marker::PhantomData,
        }
    }

    /// This function does the actual decoding
    /// It returns an Option<string> if it was successful
    /// Else the Option returns nothing and the error is logged in Trace
    fn crack(&self, text: &str, checker: &CheckerTypes) -> CrackResult {
        trace!("Trying ASCII85 with text {:?}", text);
        let decoded_text = decode_ascii85_no_error_handling(text);
        let mut results = CrackResult::new(self, text.to_string());

        if decoded_text.is_none() {
            debug!("Failed to decode ascii85 because ASCII85Decoder::decode_ascii85_no_error_handling returned None");
            return results;
        }

        let decoded_text = decoded_text.unwrap();
        if !check_string_success(&decoded_text, text) {
            info!(
                "Failed to decode ascii85 because check_string_success returned false on string {}",
                decoded_text
            );
            return results;
        }

        let checker_result = checker.check(&decoded_text);
        results.unencrypted_text = Some(vec![decoded_text]);

        results.update_checker(&checker_result);

        results
    }
    /// Gets all tags for this decoder
    fn get_tags(&self) -> &Vec<&str> {
        &self.tags
    }
    /// Gets the name for the current decoder
    fn get_name(&self) -> &str {
        self.name
    }
}

/// helper function
fn decode_ascii85_no_error_handling(text: &str) -> Option<String> {
    // Runs the code to decode ascii85
    // Doesn't perform error handling, call from_ascii85
    ascii85::decode(text)
        .ok()
        .map(|inner| String::from_utf8(inner).ok())?
}

#[cfg(test)]
mod tests {
    use super::ASCII85Decoder;
    use crate::{
        checkers::{
            athena::Athena,
            checker_type::{Check, Checker},
            CheckerTypes,
        },
        decoders::interface::{Crack, Decoder},
    };

    // helper for tests
    fn get_athena_checker() -> CheckerTypes {
        let athena_checker = Checker::<Athena>::new();
        CheckerTypes::CheckAthena(athena_checker)
    }

    #[test]
    fn ascii85_successful_decoding_short_string() {
        let ascii85_decoder = Decoder::<ASCII85Decoder>::new();

        let result = ascii85_decoder.crack("BOu!rD]j7BEbo7", &get_athena_checker());
        let decoded_str = &result
            .unencrypted_text
            .expect("No unencrypted text for ascii85");
        assert_eq!(decoded_str[0], "hello world");
    }

    #[test]
    fn ascii85_successful_decoding_long_string() {
        let ascii85_decoder = Decoder::<ASCII85Decoder>::new();

        let result = ascii85_decoder.crack("<+ohcEHPu*CER),Dg-(AAoDo:C3=B4ARlp%G%G\\:FD,5.CghX8+CoD'F\"Re,.j-*V1ZF\"f+iC*l+Msit_kP,8_P[", &get_athena_checker());
        let decoded_str = &result
            .unencrypted_text
            .expect("No unencrypted text for ascii85");
        assert_eq!(decoded_str[0], "The quick brown fox jumped over the lazy dogs.\n\n+ $p3â‚¬!Ã¤l Â¢#Ã¢Å•Â§");
    }

    #[test]
    fn ascii85_decode_handles_panics() {
        let ascii85_decoder = Decoder::<ASCII85Decoder>::new();
        let result = ascii85_decoder
            .crack(
                "hello my name is panicky mc panic face!",
                &get_athena_checker(),
            )
            .unencrypted_text;
        if result.is_some() {
            panic!("Decode_ascii85 did not return an option with Some<t>.")
        } else {
            // If we get here, the test passed
            // Because the ascii85_decoder.crack function returned None
            // as it should do for the input
            assert_eq!(true, true);
        }
    }

    #[test]
    fn ascii85_handle_panic_if_empty_string() {
        // This tests if ASCII85 can handle an empty string
        // It should return None
        let ascii85_decoder = Decoder::<ASCII85Decoder>::new();
        let result = ascii85_decoder
            .crack("", &get_athena_checker())
            .unencrypted_text;
        if result.is_some() {
            assert_eq!(true, true);
        }
    }

    #[test]
    fn ascii85_handle_panic_if_emoji() {
        let ascii85_decoder = Decoder::<ASCII85Decoder>::new();
        let result = ascii85_decoder
            .crack("ðŸ˜‚", &get_athena_checker())
            .unencrypted_text;
        if result.is_some() {
            assert_eq!(true, true);
        }
    }
}
