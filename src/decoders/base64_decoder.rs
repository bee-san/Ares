///! Decode a base64 string
///! Performs error handling and returns a string
///! Call base64_decoder.crack to use. It returns option<String> and check with
///! `result.is_some()` to see if it returned okay.

use log::{trace};
use super::interface::Decoder;


/// .decoder is never used, so Rust considers this dead code
/// Really it's just a coreference to the Decoder in `interface.rs`
#[allow(dead_code)] 
pub struct Base64Decoder {
    decoder: Decoder,
}

/// The Base64 decoder, call:
/// `let base64_decoder = Base64Decoder.new()` to create a new instance
/// And then call:
/// `result = base64_decoder.crack(input)` to decode a base64 string
/// The struct generated by new() comes from interface.rs
impl Base64Decoder {
    pub fn new() -> Self {
        Self {
            decoder: Decoder {
                name: "base64",
                description: " Base64 is a group of binary-to-text encoding schemes that represent binary data (more specifically, a sequence of 8-bit bytes) in an ASCII string format by translating the data into a radix-64 representation.",
                link: "https://en.wikipedia.org/wiki/Base64",
                tags: vec!["base64", "decoder", "baser"],
                expected_runtime: 0.01,
                expected_success: 1.0,
                failure_runtime: 0.01,
                normalised_entropy: vec![1.0, 10.0],
                popularity: 1.1,
            },
        }
    }

    fn decode_base64_no_error_handling(text: &str) -> Result<String, base64::DecodeError> {
        // Runs the code to decode base64
        // Doesn't perform error handling, call from_base64
        let bytes = base64::decode(text)?;
        let ascii_string = String::from_utf8(bytes).unwrap();
        Ok(ascii_string)
    }

    /// This function does the actual decoding
    /// It returns an Option<string> if it was successful
    /// Else the Option returns nothing and the error is logged in Trace
    pub fn crack(&self, text: &str) -> Option<String> {
        trace!("Trying Base64 with text {:?}", text);
        let result = Base64Decoder::decode_base64_no_error_handling(text);
        match result {
            Ok(x) => Some(x),
            Err(_) => {
                trace!("Failed to decode base64.");
                None
                }
            }
        }
}

#[cfg(test)]
mod tests {
    use crate::decoders::base64_decoder::{Base64Decoder};

    #[test]
    fn it_works() {
        let base64_decoder = Base64Decoder::new();
        let _result = base64_decoder.Crack("aGVsbG8gd29ybGQ=").unwrap();
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn successful_decoding(){
        let base64_decoder = Base64Decoder::new();
        let result = base64_decoder.Crack("aGVsbG8gd29ybGQ=").unwrap();
        assert_eq!(result, "hello world");
    }

    #[test]
    fn base64_decode_empty_string(){
        let base64_decoder = Base64Decoder::new();
        let result = base64_decoder.Crack("").unwrap();
        assert_eq!(result, "");
    }

    #[test]
    fn base64_decode_handles_panics() {
        let base64_decoder = Base64Decoder::new();
        let result = base64_decoder.Crack("hello my name is panicky mc panic face!");
        if result.is_some() {
            panic!("Decode_base64 did not return an option with Some<t>.")
            
        }
        else {
            // If we get here, the test passed
            // Because the base64_decoder.crack function returned None
            // as it should do for the input
            assert_eq!(true, true);
        }
    }
}