//! Run a brainfuck program and return its output
//! Performs error handling and returns a string
//! Call brainfuck_interpreter.crack to use. It returns Option<String> and check with
//! `result.is_some()` to see if it returned okay.
use crate::checkers::CheckerTypes;

use super::crack_results::CrackResult;
use super::interface::Crack;
use super::interface::Decoder;

use log::{debug, trace};

/// The Brainfuck interpreter, call:
/// `let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new()` to create a new instance
/// And then call:
/// `result = brainfuck_interpreter.crack(input)` to interpret a Brainfuck program
/// The struct generated by new() comes from interface.rs
/// ```
/// use ares::decoders::brainfuck_interpreter::{BrainfuckInterpreter};
/// use ares::decoders::interface::{Crack, Decoder};
/// use ares::checkers::{athena::Athena, CheckerTypes, checker_type::{Check, Checker}};
///
/// let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new();
/// let athena_checker = Checker::<Athena>::new();
/// let checker = CheckerTypes::CheckAthena(athena_checker);
///
/// let result = brainfuck_interpreter.crack(">++++++++[<+++++++++>-]<.>++++[<+++++++>-]<+.+++++++..+++.>>++++++[<+++++++>-]<++.------------.>++++++[<+++++++++>-]<+.<.+++.------.--------.>>>++++[<++++++++>-]<+.", &checker).unencrypted_text;
/// assert!(result.is_some());
/// assert_eq!(result.unwrap()[0], "Hello, World!");
/// ```
pub struct BrainfuckInterpreter;

impl Crack for Decoder<BrainfuckInterpreter> {
    fn new() -> Decoder<BrainfuckInterpreter> {
        Decoder {
            name: "Brainfuck",
            description: "Brainfuck is an esoteric programming language created in 1993 by Swiss student Urban MÃ¼ller. Designed to be extremely minimalistic, the language consists of only eight simple commands, a data pointer, and an instruction pointer.",
            link: "https://en.wikipedia.org/wiki/Brainfuck",
            tags: vec!["decoder", "brainfuck"],
            popularity: 0.4,
            phantom: std::marker::PhantomData,
        }
    }

    /// This function does the actual decoding
    /// It returns an Option<string> if it was successful
    /// Else the Option returns nothing and the error is logged in Trace
    fn crack(&self, text: &str, checker: &CheckerTypes) -> CrackResult {
        trace!("Trying brainfuck with text {:?}", text);
        let mut results = CrackResult::new(self, text.to_string());
        let tokens_result = bf_tokenize(text);
        match tokens_result {
            Ok(tokens) => {
                let decoded_text = bf_interpret(tokens, text.len());

                let checker_result = checker.check(&decoded_text);
                results.unencrypted_text = Some(vec![decoded_text]);

                results.update_checker(&checker_result);

                return results;
            }
            Err(e) => {
                debug!("Failed to interpret Brainfuck because of error {:?}", e);
                return results;
            }
        }
    }
    /// Gets all tags for this decoder
    fn get_tags(&self) -> &Vec<&str> {
        &self.tags
    }
    /// Gets the name for the current decoder
    fn get_name(&self) -> &str {
        self.name
    }
}

// Tokens representing higher-level Brainfuck operations
#[derive(PartialEq)]
enum Operation {
    Add,
    Move,
    Print,
    JumpAhead,
    JumpBack,
}

struct Instruction {
    op: Operation,
    count: i32, // One might optimize this so the count type is reduced for
}

#[derive(std::fmt::Debug)]
enum TokenizingError {
    FoundRead,
    NoPrint,
    UnmatchedBracket,
    EmptyInput,
}

/// Creates a midly optimized list of Tokens from a string
fn bf_tokenize(text: &str) -> Result<Vec<Instruction>, TokenizingError> {
    if text.is_empty() {
        return Err(TokenizingError::EmptyInput);
    }
    if !text.contains('.') {
        return Err(TokenizingError::NoPrint);
    }

    let mut jumplist = vec![];

    let mut list = vec![];
    for c in text.chars() {
        match c {
            '+' => push_to_list(&mut list, Operation::Add, 1),
            '-' => push_to_list(&mut list, Operation::Add, -1),
            '<' => push_to_list(&mut list, Operation::Move, -1),
            '>' => push_to_list(&mut list, Operation::Move, 1),
            '.' => push_to_list(&mut list, Operation::Print, 1),
            ',' => return Err(TokenizingError::FoundRead),
            '[' => {
                jumplist.push(list.len());
                list.push(Instruction {
                    op: Operation::JumpAhead,
                    count: 0,
                })
            }
            ']' => {
                if let Some(i) = jumplist.pop() {
                    list[i].count = list.len() as i32;
                    list.push(Instruction {
                        op: Operation::JumpBack,
                        count: i as i32,
                    })
                } else {
                    return Err(TokenizingError::UnmatchedBracket);
                }
            }
            _ => (),
        }
    }

    if !jumplist.is_empty() {
        return Err(TokenizingError::UnmatchedBracket);
    }

    Ok(list)
}

// Interprets a list of Tokens
fn bf_interpret(list: Vec<Instruction>, array_len: usize) -> String {
    let mut array: Vec<u8> = vec![0; array_len.min(30_000)];
    let mut program_pointer = 0;
    let mut output = "".to_string();

    let mut exec_cursor = 0;

    while exec_cursor < list.len() {
        let action = &list[exec_cursor];
        match action.op {
            Operation::Add => {
                array[program_pointer] =
                    array[program_pointer].wrapping_add_signed(action.count as i8)
            }
            Operation::Move => {
                program_pointer = program_pointer.wrapping_add_signed(action.count as isize);
                if program_pointer >= array_len {
                    program_pointer -= array_len
                }
            }
            Operation::Print => {
                output += &char::from(array[program_pointer])
                    .to_string()
                    .repeat(action.count.try_into().unwrap_or_default())
            }
            Operation::JumpAhead if array[program_pointer] == 0 => {
                exec_cursor = action.count as usize
            }
            Operation::JumpBack if array[program_pointer] != 0 => {
                exec_cursor = action.count as usize
            }
            _ => (),
        }

        exec_cursor += 1
    }

    output
}

/// Helper function to add a Instruction to list in an optimized way
fn push_to_list(list: &mut Vec<Instruction>, op: Operation, count: i32) {
    match list.last_mut() {
        Some(t) if t.op == op => t.count += count,
        _ => list.push(Instruction { op, count }),
    }
}

#[cfg(test)]
mod tests {
    use super::BrainfuckInterpreter;
    use crate::{
        checkers::{
            athena::Athena,
            checker_type::{Check, Checker},
            CheckerTypes,
        },
        decoders::interface::{Crack, Decoder},
    };

    // helper for tests
    fn get_athena_checker() -> CheckerTypes {
        let athena_checker = Checker::<Athena>::new();
        CheckerTypes::CheckAthena(athena_checker)
    }

    #[test]
    fn brainfuck_successful_decoding_regular_string() {
        let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new();
        let result = brainfuck_interpreter.crack(
            ">++++++++[<+++++++++>-]<.>++++[<+++++++>-]<+.+++++++..+++.>>++++++[<+++++++>-]
            <++.------------.>++++++[<+++++++++>-]<+.<.+++.------.--------.>>>++++[<++++++++>-]<+.",
            &get_athena_checker(),
        );
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello, World!");
    }

    #[test]
    fn brainfuck_successful_decoding_long_string() {
        let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new();
        let result = brainfuck_interpreter.crack("+++++++++[>++++++++>++++++++++++>+++++++++++>++++>+++++>++++++++>++++++++++>++++++++++++<<<<<<<<-]
            >++++.>+++.+++.>++.<-----.>>----.>>+.>>++++.+++.++.<<<<<<.>>+.-.<<<+++.>>+++.>>-.<.>>-.>+++++++.>-----..+++++++++.<<<<.>>----.>.>.<<<<+.
            -.>>++++.>++++.<<<<<-..+++.>>.<<<++++++++.>.+++.>++++.>>>>-.<<<+.-.>>+.<<.<----.<---.+.>---.>.>>>>.<<<<<<-.++++++.>>.<+++.-------.<+.
            >++++.>.<----.>.>>>++++++++.+++.>---.<<<<<++++.+++++++.<+++.>>.<--------.---.<.>>+.", &get_athena_checker());
        assert_eq!(
            result.unencrypted_text.unwrap()[0],
            "Lorem Ipsum! Oh, Happy Day! Hello World! I hope you have a lovely day!"
        );
    }

    #[test]
    fn brainfuck_successful_decoding_string_with_trash() {
        let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new();
        let result = brainfuck_interpreter.crack(">++++++++[<+++++++++>trash-]<.>++++[<+++++++>-]<+.+++++++..+lots+of+garbage.
            >>++++++[<+++++++>-]<++.--some--random----rubbish---here-.>++++++[<+++++++++>-]<+.<.+++.------.--------.
            >>>++++[<++++++++>-]<+.", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "Hello, World!");
    }

    #[test]
    fn brainfuck_fail_unmatched_bracket() {
        let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new();
        let result = brainfuck_interpreter
            .crack("+++++[-.-.-.-.[++]", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
        let result = brainfuck_interpreter
            .crack("+++++[-.-.-.-.]++]", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn brainfuck_fail_empty_input() {
        // This tests if brainfuck_interpreter handles an empty string
        // It should return None
        let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new();
        let result = brainfuck_interpreter
            .crack("", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn brainfuck_fail_no_print() {
        let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new();
        let result = brainfuck_interpreter
            .crack("+-<>[]", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn brainfuck_fail_read() {
        let brainfuck_interpreter = Decoder::<BrainfuckInterpreter>::new();
        let result = brainfuck_interpreter
            .crack("+-<>,.[]", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }
}
