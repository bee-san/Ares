//! Decodes an octal-encoded string
//! Performs error handling and returns a string
//! Call octal_decoder.crack to use. It returns option<String> and check with
//! `result.is_some()` to see if it returned okay.

use crate::checkers::CheckerTypes;
use crate::decoders::interface::check_string_success;

use super::crack_results::CrackResult;
use super::interface::Crack;
use super::interface::Decoder;

use log::{debug, info, trace};

/// The Octal decoder, call:
/// `let octal_decoder = Decoder::<OctalDecoder>::new()` to create a new instance
/// And then call:
/// `result = octal_decoder.crack(input)` to decode an octal string
/// The struct generated by new() comes from interface.rs
/// ```
/// use ciphey::decoders::octal_decoder::{OctalDecoder};
/// use ciphey::decoders::interface::{Crack, Decoder};
/// use ciphey::checkers::{athena::Athena, CheckerTypes, checker_type::{Check, Checker}};
///
/// let decode_octal = Decoder::<OctalDecoder>::new();
/// let athena_checker = Checker::<Athena>::new();
/// let checker = CheckerTypes::CheckAthena(athena_checker);
///
/// let result = decode_octal.crack("150 145 154 154 157 40 167 157 162 154 144", &checker).unencrypted_text;
/// assert!(result.is_some());
/// assert_eq!(result.unwrap()[0], "hello world");
/// ```
pub struct OctalDecoder;

/// Error enum for octal decoding
#[derive(Debug)]
enum Error {
    /// Error when no valid octal numbers are found
    NoValidOctal,
    /// Error if the result isn't valid UTF-8
    InvalidUtf8,
}

impl Crack for Decoder<OctalDecoder> {
    fn new() -> Decoder<OctalDecoder> {
        Decoder {
            name: "Octal",
            description: "Octal (base-8) encoding represents binary data using digits 0-7. Each byte is represented as a 3-digit octal number. It's commonly used in computing, particularly in Unix file permissions and some programming languages for character escapes.",
            link: "https://en.wikipedia.org/wiki/Octal",
            tags: vec!["octal", "base", "decoder"],
            popularity: 0.8,
            phantom: std::marker::PhantomData,
        }
    }

    /// This function does the actual decoding
    /// It returns an Option<string> if it was successful
    /// Else the Option returns nothing and the error is logged in Trace
    fn crack(&self, text: &str, checker: &CheckerTypes) -> CrackResult {
        trace!("Trying octal with text {:?}", text);
        let decoded_text: Result<String, Error> = octal_to_string(text);
        let mut results = CrackResult::new(self, text.to_string());

        if decoded_text.is_err() {
            debug!("Failed to decode octal: {:?}", decoded_text);
            return results;
        }

        trace!("Decoded text for octal: {:?}", decoded_text);

        let decoded_text = decoded_text.unwrap();

        if !check_string_success(&decoded_text, text) {
            info!(
                "Failed to decode octal because check_string_success returned false on string {}",
                decoded_text
            );
            return results;
        }

        let checker_result = checker.check(&decoded_text);
        results.unencrypted_text = Some(vec![decoded_text]);

        results.update_checker(&checker_result);

        results
    }

    /// Gets all tags for this decoder
    fn get_tags(&self) -> &Vec<&str> {
        &self.tags
    }

    /// Gets the name for the current decoder
    fn get_name(&self) -> &str {
        self.name
    }

    /// Gets the description for the current decoder
    fn get_description(&self) -> &str {
        self.description
    }

    /// Gets the link for the current decoder
    fn get_link(&self) -> &str {
        self.link
    }
}

/// Decodes octal to string
fn octal_to_string(octal: &str) -> Result<String, Error> {
    // Remove all non-octal characters from the string to extract just the digits
    // Also track potential delimiters to determine parsing strategy
    let cleaned: String = octal
        .chars()
        .filter(|c| {
            c.is_ascii_digit()
                || *c == ' '
                || *c == ','
                || *c == ';'
                || *c == '\t'
                || *c == '\n'
                || *c == '\r'
                || *c == '-'
                || *c == ':'
        })
        .collect();

    if cleaned.is_empty() {
        return Err(Error::NoValidOctal);
    }

    // Check if the input contains any invalid octal digits (8 or 9)
    let only_digits: String = octal.chars().filter(|c| c.is_ascii_digit()).collect();
    if only_digits.chars().any(|c| c == '8' || c == '9') {
        return Err(Error::NoValidOctal);
    }

    // Try delimiter-based parsing first
    let has_delimiters = cleaned.chars().any(|c| !c.is_ascii_digit());

    let result = if has_delimiters {
        // Split by common delimiters and parse each octal number
        parse_delimited_octal(&cleaned)
    } else {
        // No delimiters - try to parse as consecutive 3-digit octal numbers
        parse_consecutive_octal(&only_digits)
    };

    result
}

/// Parse octal string with delimiters (spaces, commas, etc.)
fn parse_delimited_octal(text: &str) -> Result<String, Error> {
    // Split by any non-digit delimiter
    let parts: Vec<&str> = text
        .split(|c: char| !c.is_ascii_digit())
        .filter(|s| !s.is_empty())
        .collect();

    if parts.is_empty() {
        return Err(Error::NoValidOctal);
    }

    let mut result = Vec::new();
    for part in parts {
        // Parse each part as an octal number
        match u8::from_str_radix(part, 8) {
            Ok(byte) => result.push(byte),
            Err(_) => {
                // If it doesn't fit in a u8, try parsing as a larger number
                // This handles numbers like "40" (space) correctly
                if let Ok(val) = u32::from_str_radix(part, 8) {
                    if val <= 255 {
                        result.push(val as u8);
                    } else {
                        return Err(Error::NoValidOctal);
                    }
                } else {
                    return Err(Error::NoValidOctal);
                }
            }
        }
    }

    String::from_utf8(result).map_err(|_| Error::InvalidUtf8)
}

/// Parse octal string without delimiters (consecutive 3-digit groups)
fn parse_consecutive_octal(text: &str) -> Result<String, Error> {
    // Standard ASCII octal encoding uses 3 digits per character
    if text.len() % 3 != 0 {
        return Err(Error::NoValidOctal);
    }

    let mut result = Vec::new();
    for chunk in text.as_bytes().chunks(3) {
        let octal_str = std::str::from_utf8(chunk).map_err(|_| Error::InvalidUtf8)?;
        match u8::from_str_radix(octal_str, 8) {
            Ok(byte) => result.push(byte),
            Err(_) => {
                // Try as u32 for values that might be larger
                if let Ok(val) = u32::from_str_radix(octal_str, 8) {
                    if val <= 255 {
                        result.push(val as u8);
                    } else {
                        return Err(Error::NoValidOctal);
                    }
                } else {
                    return Err(Error::NoValidOctal);
                }
            }
        }
    }

    String::from_utf8(result).map_err(|_| Error::InvalidUtf8)
}

#[cfg(test)]
mod tests {
    use super::OctalDecoder;
    use crate::{
        checkers::{
            athena::Athena,
            checker_type::{Check, Checker},
            CheckerTypes,
        },
        decoders::interface::{Crack, Decoder},
    };

    // helper for tests
    fn get_athena_checker() -> CheckerTypes {
        let athena_checker = Checker::<Athena>::new();
        CheckerTypes::CheckAthena(athena_checker)
    }

    #[test]
    fn octal_with_spaces_decodes_successfully() {
        // "hello world" in octal with spaces
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack(
            "150 145 154 154 157 40 167 157 162 154 144",
            &get_athena_checker(),
        );
        assert_eq!(result.unencrypted_text.unwrap()[0], "hello world");
    }

    #[test]
    fn octal_without_delimiters_decodes_successfully() {
        // "hello" in octal without delimiters (each char is 3 digits)
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack("150145154154157", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "hello");
    }

    #[test]
    fn octal_with_commas_decodes_successfully() {
        // "hello" with comma delimiters
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack("150,145,154,154,157", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "hello");
    }

    #[test]
    fn octal_with_semicolons_decodes_successfully() {
        // "hello" with semicolon delimiters
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack("150;145;154;154;157", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "hello");
    }

    #[test]
    fn octal_with_newlines_decodes_successfully() {
        // "hello" with newline delimiters
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack("150\n145\n154\n154\n157", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "hello");
    }

    #[test]
    fn octal_with_mixed_delimiters_decodes_successfully() {
        // "hello" with mixed delimiters
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack("150, 145; 154 154-157", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "hello");
    }

    #[test]
    fn octal_decodes_url_successfully() {
        // "https://www.google.com" in octal with spaces
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack(
            "150 164 164 160 163 72 57 57 167 167 167 56 147 157 157 147 154 145 56 143 157 155",
            &get_athena_checker(),
        );
        assert_eq!(
            result.unencrypted_text.unwrap()[0],
            "https://www.google.com"
        );
    }

    #[test]
    fn octal_fails_on_invalid_digits() {
        // Contains '8' which is not valid octal
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder
            .crack("150 148 154", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn octal_fails_on_digit_nine() {
        // Contains '9' which is not valid octal
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder
            .crack("159 145 154", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn octal_handles_empty_string() {
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack("", &get_athena_checker()).unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn octal_handles_invalid_input() {
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder
            .crack("hello world!", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn octal_handles_emoji() {
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack("ðŸ˜‚", &get_athena_checker()).unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn octal_handles_whitespace_only() {
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder
            .crack("   \t\n  ", &get_athena_checker())
            .unencrypted_text;
        assert!(result.is_none());
    }

    #[test]
    fn octal_leading_zeros_decode_successfully() {
        // "hello" with leading zeros (4 digits each, still valid)
        let decoder = Decoder::<OctalDecoder>::new();
        let result = decoder.crack("0150 0145 0154 0154 0157", &get_athena_checker());
        assert_eq!(result.unencrypted_text.unwrap()[0], "hello");
    }
}
